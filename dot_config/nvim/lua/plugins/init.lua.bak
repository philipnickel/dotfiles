-- Plugin manager initialization
-- Using lazy.nvim as the plugin manager

local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
  vim.fn.system({
    "git",
    "clone",
    "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable", -- latest stable release
    lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)

require("lazy").setup({
  -- Import all plugin configurations
  { import = "plugins.nordic" },
  { import = "plugins.noice" },
  { import = "plugins.neoclip" },
  { import = "plugins.flash" },
  { import = "plugins.surround" },
  { import = "plugins.chezmoi" },
  { import = "plugins.copilot" },
  { import = "plugins.tmux" },
  { import = "plugins.vimtex" },
  { import = "plugins.texpresso" },
  { import = "plugins.zotero" },
  { import = "plugins.quarto" },
  { import = "plugins.slime" },
  { import = "plugins.uv" },
  { import = "plugins.nabla" },
  { import = "plugins.img-clip" },
  { import = "plugins.avante" },
  { import = "plugins.lazygit" },
  { import = "plugins.peekup" },
  { import = "plugins.render-markdown" },
  { import = "plugins.luasnip" },
  { import = "plugins.luasnip-latex" },
  { import = "plugins.dashboard" },
  { import = "plugins.neo-tree" },
  { import = "plugins.lsp" },
  { import = "plugins.cmp" },
  { import = "plugins.treesitter" },
  { import = "plugins.undotree" },
  { import = "plugins.gitsigns" },
        { import = "plugins.indent-blankline" },
        { import = "plugins.lualine" },
        { import = "plugins.toggleterm" },
        { import = "plugins.aerial" },
        { import = "plugins.trouble" },
  
  -- Telescope (essential for navigation)
  {
    "nvim-telescope/telescope.nvim",
    tag = "0.1.6",
    dependencies = { "nvim-lua/plenary.nvim" },
    config = function()
      local telescope = require("telescope")
      local actions = require("telescope.actions")
      local action_state = require("telescope.actions.state")
      local pickers = require("telescope.pickers")
      local finders = require("telescope.finders")
      local conf = require("telescope.config").values
      local scan = require("plenary.scandir")

      telescope.setup({
        defaults = {
          mappings = {
            i = {
              ["<C-u>"] = false,
              ["<C-d>"] = false,
              ["<C-j>"] = actions.move_selection_next,
              ["<C-k>"] = actions.move_selection_previous,
            },
            n = {
              ["<C-j>"] = actions.move_selection_next,
              ["<C-k>"] = actions.move_selection_previous,
            },
          },
        },
      })

      local function directory_picker(opts)
        opts = opts or {}
        local cwd = opts.cwd or vim.loop.cwd()
        if not cwd or cwd == "" then
          cwd = vim.fn.getcwd()
        end

        local results = scan.scan_dir(cwd, {
          hidden = false,
          add_dirs = true,
          only_dirs = true,
          respect_gitignore = true,
          depth = opts.depth or 6,
        }) or {}

        local seen = {}
        local normalized_results = {}
        for _, path in ipairs(results) do
          local norm = vim.fs.normalize(path)
          if not seen[norm] then
            seen[norm] = true
            table.insert(normalized_results, norm)
          end
        end
        local norm_cwd = vim.fs.normalize(cwd)
        if not seen[norm_cwd] then
          table.insert(normalized_results, norm_cwd)
        end
        table.sort(normalized_results)

        local devicons_avail, devicons = pcall(require, "nvim-web-devicons")
        local entry_display = require("telescope.pickers.entry_display")
        local displayer = entry_display.create({
          separator = " ",
          items = {
            { width = 2 },
            { remaining = true },
          },
        })

        local function make_entry(path)
          local normalized_cwd = vim.fs.normalize(cwd)
          local normalized_path = vim.fs.normalize(path)
          local display
          if normalized_path == normalized_cwd then
            display = "./"
          elseif normalized_path:sub(1, #normalized_cwd + 1) == normalized_cwd .. "/" then
            display = normalized_path:sub(#normalized_cwd + 2)
          else
            display = normalized_path
          end

          local icon, icon_hl = "", "Directory"
          if devicons_avail then
            local dev_icon, dev_hl = devicons.get_icon(display, nil, { default = true })
            icon = dev_icon or icon
            icon_hl = dev_hl or icon_hl
          end

          return {
            value = normalized_path,
            ordinal = display,
            display = function(_)
              return displayer({
                { icon, icon_hl },
                display,
              })
            end,
          }
        end

        pickers.new(opts, {
          prompt_title = "Directories",
          finder = finders.new_table({
            results = normalized_results,
            entry_maker = make_entry,
          }),
          sorter = conf.generic_sorter(opts),
          previewer = require("telescope.previewers").new_buffer_previewer({
            title = "Directory contents",
            define_preview = function(self, entry)
              local dir = entry.value
              local lines = {}
              local highlights = {}
              if dir and vim.fn.isdirectory(dir) == 1 then
                local scan_handle = vim.loop.fs_scandir(dir)
                if scan_handle then
                  while true do
                    local name, t = vim.loop.fs_scandir_next(scan_handle)
                    if not name then
                      break
                    end
                    local icon, icon_hl
                    if devicons_avail then
                      icon, icon_hl = devicons.get_icon(name, nil, { default = true })
                    end
                    if not icon then
                      icon = t == "directory" and "" or ""
                    end
                    local text = string.format("%s %s", icon, name)
                    table.insert(lines, text)
                    highlights[#lines] = {
                      hl = icon_hl or (t == "directory" and "Directory" or "Identifier"),
                      len = #icon,
                    }
                  end
                  table.sort(lines)
                end
              end
              if vim.tbl_isempty(lines) then
                lines = { '[empty]' }
              end
              vim.api.nvim_buf_set_lines(self.state.bufnr, 0, -1, false, lines)
              for idx, hl in pairs(highlights) do
                if hl.hl and hl.len and hl.len > 0 then
                  vim.api.nvim_buf_add_highlight(self.state.bufnr, -1, hl.hl, idx - 1, 0, hl.len)
                end
              end
            end,
          }),
          attach_mappings = function(prompt_bufnr)
            actions.select_default:replace(function()
              local selection = action_state.get_selected_entry()
              actions.close(prompt_bufnr)
              if selection and selection.value then
                local ok, toggleterm = pcall(require, "toggleterm.terminal")
                if not ok then
                  vim.notify("toggleterm not available", vim.log.levels.WARN)
                  return
                end
                toggleterm.Terminal:new({
                  dir = selection.value,
                  direction = "vertical",
                  size = function()
                    return math.floor(vim.o.columns * 0.4)
                  end,
                }):toggle()
              end
            end)
            return true
          end,
        }):find()
      end

      vim.keymap.set("n", "<leader>fd", function()
        directory_picker()
      end, { desc = "Directories (terminal)" })

      vim.api.nvim_create_user_command("TelescopeFindDirs", function(params)
        directory_picker({ cwd = params.args ~= "" and params.args or nil })
      end, {
        nargs = "?",
        complete = "dir",
      })
    end,
  },
  
  -- Import which-key configuration
  { import = "plugins.which-key" },
  
  -- Undotree
  {
    "mbbill/undotree",
    cmd = "UndotreeToggle",
  },
  
}, {
  install = { colorscheme = { "nordic" } },
  checker = { enabled = true },
  performance = {
    rtp = {
      disabled_plugins = {
        "gzip",
        "matchit",
        "matchparen",
        "netrwPlugin",
        "tarPlugin",
        "tohtml",
        "tutor",
        "zipPlugin",
      },
    },
  },
})
