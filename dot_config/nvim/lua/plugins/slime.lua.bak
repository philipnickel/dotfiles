-- Vim-slime REPL integration configuration

return {
  "jpalardy/vim-slime",
  init = function()
    vim.b['quarto_is_python_chunk'] = false
    Quarto_is_in_python_chunk = function()
      require('otter.tools.functions').is_otter_language_context('python')
    end

    vim.cmd([[
      let g:slime_dispatch_ipython_pause = 100
      function SlimeOverride_EscapeText_quarto(text)
      call v:lua.Quarto_is_in_python_chunk()
      if len(split(a:text,"\n")) > 1 && b:quarto_is_python_chunk && !(exists('b:quarto_is_r_mode') && b:quarto_is_r_mode)
      return [a:text, "\n"]
      endif
      return [a:text]
      endfunction
    ]])

    -- Configure for WezTerm
    vim.g.slime_target = "wezterm"
    vim.g.slime_wezterm_pane_id = nil  -- Will be auto-detected
    vim.g.slime_no_mappings = true
    vim.g.slime_python_ipython = 0  -- Disable IPython magic (euporie doesn't need %cpaste)
    vim.g.slime_dont_ask_default = 1
    vim.g.slime_default_config = {}
    
    -- Bracketed paste for multiline code (works with euporie and IPython)
    vim.g.slime_bracketed_paste = 1
    
    -- Set cell delimiters based on filetype
    vim.api.nvim_create_autocmd("FileType", {
      pattern = {"python"},
      callback = function()
        -- Support both #%% and # %% (with space)
        vim.b.slime_cell_delimiter = "# %%"
      end,
    })
    
    vim.api.nvim_create_autocmd("FileType", {
      pattern = {"quarto", "markdown", "rmd"},
      callback = function()
        vim.b.slime_cell_delimiter = "```"
      end,
    })
  end,
  config = function()
    vim.g.slime_input_pid = false
    vim.g.slime_suggest_default = true
    vim.g.slime_menu_config = false

    -- Global variable to track REPL pane
    _G.repl_pane_id = nil

    -- Function to send entire file
    local function start_ipython_repl()
      -- Check for required packages
      local function check_packages()
        local has_ipython = vim.fn.executable("ipython") == 1
        local has_matplotlib = vim.fn.system("python3 -c 'import matplotlib' 2>&1"):find("No module") == nil
        local has_pillow = vim.fn.system("python3 -c 'import PIL' 2>&1"):find("No module") == nil
        
        if not has_ipython or not has_matplotlib or not has_pillow then
          local missing = {}
          if not has_ipython then table.insert(missing, "ipython") end
          if not has_matplotlib then table.insert(missing, "matplotlib") end
          if not has_pillow then table.insert(missing, "pillow") end

          local packages = table.concat(missing, ", ")
          local pip_hint = os.getenv("VIRTUAL_ENV") and "pip install " or "python3 -m pip install --user "
          vim.notify(
            ("Missing Python packages for image support: %s.\nInstall manually with `%s%s`."):format(packages, pip_hint, packages),
            vim.log.levels.WARN
          )
          return false
        end
        return true
      end
      
      if not check_packages() then
        return
      end
      
      -- Create startup script with inline plotting
      local config = [[
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from io import BytesIO
import base64
import os
import warnings

# Suppress the non-interactive backend warning
warnings.filterwarnings('ignore', message='.*FigureCanvasAgg is non-interactive.*')

# Track last displayed result to avoid duplicates
_last_displayed = None
_displayed_via_display = set()  # Track objects displayed via display()

def _display_figure(fig):
    buf = BytesIO()
    fig.savefig(buf, format='png', dpi=200, bbox_inches='tight')  # Increased DPI to 200
    buf.seek(0)
    img_data = buf.read()
    img_str = base64.b64encode(img_data).decode()
    if os.environ.get('TMUX'):
        print(f'\033Ptmux;\033\033]1337;File=inline=1;width=70%;preserveAspectRatio=1:{img_str}\a\033\\')
    else:
        print(f'\033]1337;File=inline=1;width=70%;preserveAspectRatio=1:{img_str}\a')
    buf.close()

def _render_sympy(obj):
    """Render a sympy object as LaTeX image"""
    try:
        from sympy import latex, Basic
        if isinstance(obj, Basic):
            latex_str = latex(obj)
            
            # Use transparent background with white text
            with plt.rc_context({
                'text.usetex': False,  # Use matplotlib's mathtext instead of LaTeX
                'mathtext.fontset': 'cm',  # Computer Modern font (LaTeX default)
                'font.size': 14
            }):
                # Create a temporary figure to measure text size
                temp_fig = plt.figure(figsize=(1, 1))
                temp_ax = temp_fig.add_subplot(111)
                text = temp_ax.text(0, 0, f'${latex_str}$', fontsize=14)
                temp_fig.canvas.draw()
                
                # Get the bounding box of the text in inches
                bbox = text.get_window_extent(temp_fig.canvas.get_renderer())
                bbox_inches = bbox.transformed(temp_fig.dpi_scale_trans.inverted())
                width_inches = bbox_inches.width
                height_inches = bbox_inches.height
                plt.close(temp_fig)
                
                # Add minimal padding and create appropriately sized figure
                padding_x = 0.3
                padding_y = 0.1
                fig_width = max(width_inches + padding_x, 3)  # Minimum 3 inches
                fig_height = max(height_inches + padding_y, 0.4)  # Minimum 0.4 inches
                
                fig, ax = plt.subplots(figsize=(fig_width, fig_height))
                fig.patch.set_alpha(0)  # Transparent figure background
                ax.patch.set_alpha(0)   # Transparent axes background
                ax.text(0.5, 0.5, f'${latex_str}$', 
                       fontsize=14, 
                       ha='center', 
                       va='center',
                       color='white')  # White text
                ax.axis('off')
                fig.tight_layout(pad=0)
                _display_figure(fig)
                plt.close(fig)  # Close immediately to prevent double display
            
            # Print the LaTeX code below the image for easy copying
            print(f'LaTeX: {latex_str}')
            return True
    except:
        pass
    return False

def _auto_display():
    global _last_displayed, _displayed_via_display
    
    # Display matplotlib figures (only if there are active figures)
    figs = [plt.figure(num) for num in plt.get_fignums()]
    if figs:
        for fig in figs:
            if fig.get_axes():
                _display_figure(fig)
                plt.close(fig)
        # Clear the displayed set after processing
        _displayed_via_display.clear()
        return  # Don't check for sympy if we displayed a plot
    
    # Check for sympy expressions (only if result changed and is a sympy object)
    try:
        from sympy import Basic
        result = get_ipython().user_ns.get('_', None)
        
        # Only display if it's a new sympy result and wasn't already displayed via display()
        if (result is not None and isinstance(result, Basic) and 
            result is not _last_displayed and id(result) not in _displayed_via_display):
            _last_displayed = result
            _render_sympy(result)
    except Exception as e:
        pass
    
    # Clear the displayed set after each execution
    _displayed_via_display.clear()

# Override IPython.display.display to handle sympy objects
try:
    from IPython.display import display as _original_display
    
    def display(*args, **kwargs):
        """Custom display that renders sympy as images"""
        global _displayed_via_display
        for obj in args:
            if not _render_sympy(obj):
                # Fall back to original display for non-sympy objects
                _original_display(obj, **kwargs)
            else:
                # Track that we displayed this object
                _displayed_via_display.add(id(obj))
    
    # Make it available globally
    import IPython.display
    IPython.display.display = display
    
    # Also update the global namespace
    import builtins
    builtins.display = display
except ImportError:
    pass

# Hook into sympy's init_printing to restore our display after it's called
try:
    import sympy
    _original_init_printing = sympy.init_printing
    
    def _custom_init_printing(*args, **kwargs):
        # Call original but ignore the result
        _original_init_printing(*args, **kwargs)
        # Re-register our display hook
        ip = get_ipython()
        if ip:
            # Remove the old hook and re-add ours
            ip.events.unregister('post_execute', _auto_display)
            ip.events.register('post_execute', _auto_display)
    
    sympy.init_printing = _custom_init_printing
except ImportError:
    pass

import IPython
_ip = IPython.get_ipython()
if _ip:
    _ip.events.register('post_execute', _auto_display)
    print("âœ“ Inline plotting enabled (with LaTeX rendering)!")
]]
      
      local tmpfile = "/tmp/nvim_ipython_startup.py"
      local f = io.open(tmpfile, "w")
      if f then
        f:write(config)
        f:close()
      end
      
      -- Open IPython in WezTerm and capture pane ID using wezterm cli
      if vim.fn.executable("wezterm") == 1 then
        -- Get current working directory
        local cwd = vim.fn.getcwd()
        
        -- Use wezterm cli spawn to get the pane ID directly
        local result = vim.fn.system(string.format(
          "wezterm cli spawn --new-window --cwd '%s' -- ipython --no-autoindent -i %s",
          cwd, tmpfile
        ))
        
        local pane_id = result:gsub("\n", "")
        
        if pane_id ~= "" and not pane_id:match("error") then
          _G.repl_pane_id = pane_id
          vim.g.slime_default_config = {pane_id = pane_id}
          vim.b.slime_config = {pane_id = pane_id}
          vim.notify("IPython REPL started (pane: " .. pane_id .. ")", vim.log.levels.INFO)
        else
          vim.notify("Failed to get pane ID: " .. result, vim.log.levels.ERROR)
        end
      else
        vim.notify("WezTerm CLI not found. Please install wezterm.", vim.log.levels.WARN)
      end
    end

    -- Function to start R (radian) REPL in WezTerm
    local function start_r_repl()
      -- Check if radian is installed, fallback to R
      local has_radian = vim.fn.executable("radian") == 1
      local has_r = vim.fn.executable("R") == 1
      
      if not has_radian and not has_r then
        local msg = "Neither radian nor R found. Install radian for a better experience.\nInstall radian now?"
        local choice = vim.fn.confirm(msg, "&Yes\n&No", 2)
        
        if choice == 1 then
          vim.notify("Installing radian...", vim.log.levels.INFO)
          local in_venv = os.getenv("VIRTUAL_ENV") ~= nil
          local pip_cmd = in_venv and "pip install" or "pip3 install --user"
          vim.fn.system(pip_cmd .. " radian")
          
          if vim.v.shell_error == 0 then
            vim.notify("Radian installed successfully!", vim.log.levels.INFO)
            has_radian = true
          else
            vim.notify("Failed to install radian", vim.log.levels.ERROR)
            return
          end
        else
          return
        end
      end
      
      -- Open R/radian in WezTerm
      if vim.fn.executable("wezterm") == 1 then
        -- Get current working directory
        local cwd = vim.fn.getcwd()
        local cmd = has_radian and "radian" or "R"
        
        local result = vim.fn.system(string.format(
          "wezterm cli spawn --new-window --cwd '%s' -- %s",
          cwd, cmd
        ))
        
        local pane_id = result:gsub("\n", "")
        
        if pane_id ~= "" and not pane_id:match("error") then
          _G.repl_pane_id = pane_id
          vim.g.slime_default_config = {pane_id = pane_id}
          vim.b.slime_config = {pane_id = pane_id}
          vim.notify(string.format("%s REPL started (pane: %s)", cmd, pane_id), vim.log.levels.INFO)
        else
          vim.notify("Failed to get pane ID: " .. result, vim.log.levels.ERROR)
        end
      else
        vim.notify("WezTerm CLI not found. Please install wezterm.", vim.log.levels.WARN)
      end
    end

    -- Function to send entire file
    local function send_file()
      local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
      local text = table.concat(lines, "\n")
      vim.fn['slime#send'](text .. "\n")
    end

    -- Smart REPL launcher based on filetype
    local function start_repl()
      local cwd = vim.fn.getcwd()
      local ft = vim.bo.filetype
      
      -- Determine what to launch based on filetype
      local is_python = ft == "python" or ft == "quarto"
      local is_r = ft == "r" or ft == "rmd"
      
      if not os.getenv("TMUX") then
        vim.notify("Start this in tmux", vim.log.levels.WARN)
        return
      end
      
      local start_cmd
      
      if is_python then
        -- Python: use euporie with uv
        if vim.fn.executable("uv") ~= 1 then
          vim.notify("uv not found. Install: curl -LsSf https://astral.sh/uv/install.sh | sh", vim.log.levels.ERROR)
          return
        end
        
        vim.notify("Ensuring euporie and dependencies...", vim.log.levels.INFO)
        vim.fn.system("cd '" .. cwd .. "' && uv add --quiet euporie ipykernel 2>&1")
        start_cmd = "uv run euporie-console"
        
      elseif is_r then
        -- R: use radian or R
        local has_radian = vim.fn.executable("radian") == 1
        start_cmd = has_radian and "radian" or "R"
        
      else
        vim.notify("Unsupported filetype: " .. ft, vim.log.levels.WARN)
        return
      end
      
      -- Start in tmux pane
      vim.fn.system("tmux split-window -h -c '" .. cwd .. "'")
      local pane_id = vim.fn.system("tmux display-message -p '#{pane_id}'"):gsub("\n", "")
      vim.fn.system("tmux send-keys -t " .. pane_id .. " '" .. start_cmd .. "' C-m")
      
      vim.g.slime_target = "tmux"
      vim.g.slime_default_config = {socket_name = "default", target_pane = pane_id}
      vim.b.slime_config = {socket_name = "default", target_pane = pane_id}
      vim.notify("REPL started: " .. start_cmd, vim.log.levels.INFO)
    end
    
    -- Shell launcher
    local function start_shell()
      if not os.getenv("TMUX") then
        vim.notify("Start this in tmux", vim.log.levels.WARN)
        return
      end
      
      local cwd = vim.fn.getcwd()
      vim.fn.system("tmux split-window -h -c '" .. cwd .. "'")
      local pane_id = vim.fn.system("tmux display-message -p '#{pane_id}'"):gsub("\n", "")
      
      vim.g.slime_target = "tmux"
      vim.g.slime_default_config = {socket_name = "default", target_pane = pane_id}
      vim.b.slime_config = {socket_name = "default", target_pane = pane_id}
      vim.notify("Shell started", vim.log.levels.INFO)
    end

    -- Keybindings
    vim.keymap.set('n', '<leader>rr', start_repl, { desc = 'Start REPL' })
    vim.keymap.set('n', '<leader>rs', start_shell, { desc = 'Start Shell' })
    
    -- Send code keybindings
    vim.keymap.set('n', '<leader>rl', '<Plug>SlimeLineSend', { desc = 'Run line' })
    vim.keymap.set('x', '<leader>rv', '<Plug>SlimeRegionSend', { desc = 'Run selection' })
    vim.keymap.set('n', '<leader>rb', '<Plug>SlimeSendCell', { desc = 'Run cell/block' })
    vim.keymap.set('n', '<leader>rf', send_file, { desc = 'Run file' })
  end,
}
