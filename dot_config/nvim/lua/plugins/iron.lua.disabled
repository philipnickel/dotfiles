-- Iron.nvim configuration for interactive REPLs

return {
  "Vigemus/iron.nvim",
  config = function()
    local iron = require("iron.core")
    local view = require("iron.view")

    iron.setup({
      config = {
        -- Whether a repl should be discarded or not
        scratch_repl = true,
        
        -- Your repl definitions come here
        repl_definition = {
          sh = {
            command = {"zsh"}
          },
          python = {
            command = function()
              -- Check for required packages and prompt to install if missing
              local function check_and_install_packages()
                -- Check if we're in a virtual environment
                local in_venv = os.getenv("VIRTUAL_ENV") ~= nil
                
                -- Check if ipython and matplotlib are available
                local has_ipython = vim.fn.executable("ipython") == 1
                local has_matplotlib = vim.fn.system("python3 -c 'import matplotlib' 2>&1"):find("No module") == nil
                local has_pillow = vim.fn.system("python3 -c 'import PIL' 2>&1"):find("No module") == nil
                
                if not has_ipython or not has_matplotlib or not has_pillow then
                  local missing = {}
                  if not has_ipython then table.insert(missing, "ipython") end
                  if not has_matplotlib then table.insert(missing, "matplotlib") end
                  if not has_pillow then table.insert(missing, "pillow") end
                  
                  local msg = "Missing packages: " .. table.concat(missing, ", ") .. "\nInstall now?"
                  local choice = vim.fn.confirm(msg, "&Yes\n&No", 2)
                  
                  if choice == 1 then
                    local pip_cmd = in_venv and "pip install" or "pip3 install --user"
                    local install_cmd = pip_cmd .. " " .. table.concat(missing, " ")
                    
                    vim.notify("Installing packages...", vim.log.levels.INFO)
                    local result = vim.fn.system(install_cmd)
                    
                    if vim.v.shell_error == 0 then
                      vim.notify("Packages installed successfully!", vim.log.levels.INFO)
                    else
                      vim.notify("Failed to install packages:\n" .. result, vim.log.levels.ERROR)
                    end
                  end
                end
              end
              
              check_and_install_packages()
              
              -- Check if in WezTerm and use external window if available
              if vim.env.TERM_PROGRAM == "WezTerm" and vim.fn.executable("wezterm") == 1 then
                -- Create inline plot configuration with iTerm2 protocol
                local config = [[
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from io import BytesIO
import base64
import os

def _display_figure(fig):
    buf = BytesIO()
    fig.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    img_data = buf.read()
    img_str = base64.b64encode(img_data).decode()
    if os.environ.get('TMUX'):
        print(f'\033Ptmux;\033\033]1337;File=inline=1;width=33%;preserveAspectRatio=1:{img_str}\a\033\\')
    else:
        print(f'\033]1337;File=inline=1;width=33%;preserveAspectRatio=1:{img_str}\a')
    buf.close()

def _auto_display():
    figs = [plt.figure(num) for num in plt.get_fignums()]
    for fig in figs:
        if fig.get_axes():
            _display_figure(fig)
            plt.close(fig)

import IPython
_ip = IPython.get_ipython()
if _ip:
    _ip.events.register('post_execute', _auto_display)
    print("âœ“ Inline plotting enabled - plots display automatically!")
]]
                
                local tmpfile = "/tmp/nvim_ipython_startup.py"
                local f = io.open(tmpfile, "w")
                if f then
                  f:write(config)
                  f:close()
                end
                
                -- Use wezterm start to open a new window
                if vim.fn.executable("ipython") == 1 then
                  return {"wezterm", "start", "--", "ipython", "--no-autoindent", "-i", tmpfile}
                end
              end
              
              -- Fallback to regular ipython
              if vim.fn.executable("ipython") == 1 then
                return {"ipython", "--no-autoindent"}
              elseif vim.fn.executable("python3") == 1 then
                return {"python3"}
              elseif vim.fn.executable("python") == 1 then
                return {"python"}
              else
                vim.notify("No Python interpreter found. Please install Python or IPython.", vim.log.levels.ERROR)
                return {"python"}
              end
            end,
            format = require("iron.fts.common").bracketed_paste_python,
            block_dividers = { "# %%", "#%%" },
            env = {PYTHON_BASIC_REPL = "1"}
          },
          r = {
            command = function()
              if vim.fn.executable("R") == 1 then
                return {"R"}
              else
                vim.notify("R is not installed or not in PATH", vim.log.levels.ERROR)
                return {"R"}
              end
            end
          },
          julia = {
            command = function()
              if vim.fn.executable("julia") == 1 then
                return {"julia"}
              else
                vim.notify("Julia is not installed or not in PATH", vim.log.levels.ERROR)
                return {"julia"}
              end
            end
          },
          lua = {
            command = {"lua"}
          },
          -- Support for Quarto/Markdown files
          quarto = {
            command = function()
              -- Try ipython first, fallback to python
              if vim.fn.executable("ipython") == 1 then
                return {"ipython", "--no-autoindent"}
              elseif vim.fn.executable("python3") == 1 then
                return {"python3"}
              elseif vim.fn.executable("python") == 1 then
                return {"python"}
              else
                vim.notify("No Python interpreter found for Quarto", vim.log.levels.ERROR)
                return {"python"}
              end
            end,
            format = require("iron.fts.common").bracketed_paste_python,
            block_dividers = { "```{python}", "```{r}", "```{julia}", "```{bash}", "```" },
            env = {PYTHON_BASIC_REPL = "1"}
          },
          markdown = {
            command = function()
              -- Try ipython first, fallback to python
              if vim.fn.executable("ipython") == 1 then
                return {"ipython", "--no-autoindent"}
              elseif vim.fn.executable("python3") == 1 then
                return {"python3"}
              elseif vim.fn.executable("python") == 1 then
                return {"python"}
              else
                vim.notify("No Python interpreter found for Markdown", vim.log.levels.ERROR)
                return {"python"}
              end
            end,
            format = require("iron.fts.common").bracketed_paste_python,
            block_dividers = { "```{python}", "```{r}", "```{julia}", "```{bash}", "```" },
            env = {PYTHON_BASIC_REPL = "1"}
          },
        },
        
        -- Repl window will be displayed as a vertical split (40% width)
        repl_open_cmd = view.split.vertical.botright("40%"),
        
        -- Set the file type of the newly created repl to ft
        repl_filetype = function(bufnr, ft)
          -- For Quarto/Markdown files, detect the language in the current chunk
          if ft == "quarto" or ft == "markdown" then
            local ok_otter, otter_keeper = pcall(require, 'otter.keeper')
            if ok_otter then
              local current = otter_keeper.get_current_language_context()
              if current and current ~= "" then
                return current
              end
            end
            -- Fallback to python for Quarto/Markdown
            return "python"
          end
          return ft
        end,
        
      },
      
      -- Iron doesn't set keymaps by default anymore
      keymaps = {
        toggle_repl = "<leader>rr",
        restart_repl = "<leader>rR",
        send_motion = "<leader>rs",
        visual_send = "<leader>rv",
        send_file = "<leader>rf",
        send_line = "<leader>rl",
        send_paragraph = "<leader>rp",
        send_until_cursor = "<leader>ru",
        send_mark = "<leader>rm",
        mark_motion = "<leader>rm",
        mark_visual = "<leader>rm",
        remove_mark = "<leader>rm",
        cr = "<leader>rs<cr>",
        clear = "<leader>rc",
        -- Additional keymaps for code blocks
        send_code_block = "<leader>rb",
        send_code_block_and_move = "<leader>rn",
      },
      
      -- If the highlight is on, you can change how it looks
      highlight = {
        italic = true
      },
      
      -- Ignore blank lines when sending visual select lines
      ignore_blank_lines = true,
    })

    -- Additional keymaps for iron focus and hide
    vim.keymap.set('n', '<leader>rF', '<cmd>IronFocus<cr>', { desc = 'Focus REPL' })
    vim.keymap.set('n', '<leader>rh', '<cmd>IronHide<cr>', { desc = 'Hide REPL' })

    -- Custom functions for Quarto/Markdown code chunks
    local function get_quarto_code_chunk()
      local current_line = vim.fn.line('.')
      local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
      
      local start_line = nil
      local end_line = nil
      
      -- Find the start of the current code chunk
      for i = current_line, 1, -1 do
        if lines[i] and lines[i]:match('^```{') then
          start_line = i + 1
          break
        end
      end
      
      -- Find the end of the current code chunk
      for i = current_line, #lines do
        if lines[i] and lines[i] == '```' then
          end_line = i - 1
          break
        end
      end
      
      if start_line and end_line and start_line <= end_line then
        return vim.api.nvim_buf_get_lines(0, start_line - 1, end_line, false)
      end
      
      return nil
    end

    local function send_quarto_chunk()
      local start_line, end_line = nil, nil
      local current_line = vim.fn.line('.')
      local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)

      -- Find the start of the current code chunk
      for i = current_line, 1, -1 do
        if lines[i] and lines[i]:match('^```{') then
          start_line = i + 1
          break
        end
      end

      -- Find the end of the current code chunk
      for i = current_line, #lines do
        if lines[i] and lines[i] == '```' then
          end_line = i - 1
          break
        end
      end

      if start_line and end_line and start_line <= end_line then
        -- Set visual selection to the code chunk
        vim.api.nvim_win_set_cursor(0, {start_line, 0})
        vim.cmd('normal! V')
        vim.api.nvim_win_set_cursor(0, {end_line, 0})
        
        -- Send the visual selection using Iron's visual send keymap
        vim.cmd('normal! <leader>rv')
      else
        vim.notify("No code chunk found at cursor position", vim.log.levels.WARN)
      end
    end

    -- Custom keymaps for Quarto code chunks
    vim.keymap.set('n', '<leader>rb', send_quarto_chunk, { desc = 'Send Quarto code chunk' })
  end,
}